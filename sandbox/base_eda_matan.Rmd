---
title: "Project Basic EDA: ICU Catheter Analysis"
author: "Matan"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(tidyverse)
library(skimr)
library(tableone)
library(GGally)
library(naniar)
library(ggridges)
library(ggcorrplot)
library(factoextra)
library(vcd)
library(glmnet)
library(dplyr)
library(knitr)
```

# Research Question & Notations

### Question:

Among adult ICU stays for mechanically ventilated, hemodynamically stable patients with respiratory failure, what is the causal effect of receiving an arterial catheter within the first 24 hours of ICU admission (treatment) versus not receiving one on the risk of in-hospital death within 28 days (outcome)?

### Notations:

**Population-** Adult ICU stays for patients with respiratory failure who were mechanically ventilated on day 1 and hemodynamically stable at admission.

**Unit of analysis-** Each ICU admission (icustay_id).

**Time-zero-** the first 24 hours of ICU admission.

**Treatment-** Arterial catheter placed within 24 hours of ICU admission (aline_flg = 1 means catheter in first day; 0 means none).

**Outcome-** In-hospital mortality within 28 days of ICU admission (day_28_flg: 1 = died, 0 = survived).

## DataSet

**Name & Source-** Subset of the MIMIC-II database, assembled for Chapter 16 of Secondary Analysis of EHR ([Link](https://physionet.org/content/mimic2-iaccd/1.0/))

[Key variables available:]{.underline}

-   Demographics & stay details: age, gender, service unit (FICU/MICU/SICU), admission day/hour.

-   Severity scores: SAPS I (sapsi_first), SOFA (sofa_first).

-   Vital signs & labs (first measurements): mean arterial pressure (map_1st), heart rate (hr_1st), SpO₂ (spo2_1st), WBC, creatinine, etc.

-   Comorbidity flags: sepsis, CHF, COPD, renal disease, liver disease, CAD, stroke, malignancy, respiratory disease.

-   Lengths of stay: ICU LOS (icu_los_day), hospital LOS (hospital_los_day).

-   Treatment flag: aline_flg (arterial line in first 24 h).

-   Outcome flags: hosp_exp_flg, icu_exp_flg, day_28_flg, censoring indicators.

[How treatment was allocated in practice:]{.underline}\
Clinician decision based on monitoring needs and perceived severity.\
Reasonable to assume that more severe or unstable patients are more likely to receive an arterial line.

[Key potential confounders:\
]{.underline}Baseline severity (SAPS I, SOFA), age, comorbidities, initial vital signs/labs, service unit type, admission timing. (This were chosen based on the analysis below)

[Potential effect-modifiers:]{.underline}\
Age group, baseline score strata, service unit, comorbidity burden.

### EDA for detection of con-founders & effect modifiers

```{r data-load}
df <- read.csv("../data/full_cohort_data.csv")
skim(df)
```

### Treatment & outcome distribution

```{r treat-outcome}
df %>% 
  count(aline_flg) %>% 
  mutate(pct = n / sum(n) * 100) %>% 
  rename(Catheter = aline_flg)

df %>% 
  count(day_28_flg) %>% 
  mutate(pct = n / sum(n) * 100) %>% 
  rename(Death28d = day_28_flg)
```

## Missing Values analysis & handling

```{r}
# 1. Percentage of rows with at least one missing value
total_rows        <- nrow(df)
rows_with_missing <- sum(!complete.cases(df))
pct_rows_missing  <- rows_with_missing / total_rows * 100
cat(sprintf("Rows with ≥1 missing: %d / %d (%.2f%%)\n", 
            rows_with_missing, total_rows, pct_rows_missing))

# 2. Percentage of missing values per column
col_pct_missing <- sapply(df, function(col) mean(is.na(col)) * 100)

missing_summary <- data.frame(
  variable    = names(col_pct_missing),
  pct_missing = col_pct_missing,
  row.names   = NULL
)

print(missing_summary)


```

```{r}
# we remove the bmi variable from the df
df <- df %>% select(-bmi)
```

## Fitting models with lasso to find key covariates

Fitting a logistic regression model to identify covariates that predict treatment

```{r}
# Load required libraries
if (!require(glmnet)) install.packages("glmnet")
library(glmnet)
library(dplyr)
library(tibble)
library(knitr)

# 1. Prepare data: convert character columns to factors, drop missing
df_lasso <- df %>%
  mutate(across(where(is.character), as.factor)) %>%
  drop_na()

# 2. Define response vector y and design matrix X,
#    excluding outcome and day-of-week/time columns
y <- df_lasso$aline_flg
X <- model.matrix(
  aline_flg ~ . 
    - day_28_flg 
    - day_icu_intime 
    - day_icu_intime_num
    - icu_exp_flg
    - icu_los_day
    - hour_icu_intime,
  data = df_lasso
)[, -1]

# 3. Cross-validated LASSO logistic regression
set.seed(123)
cvfit <- cv.glmnet(
  x           = X,
  y           = y,
  family      = "binomial",
  alpha       = 1,
  standardize = TRUE
)

# 4. Fit final model at the optimal λ
lambda_min <- cvfit$lambda.min
lasso_mod   <- glmnet(
  x           = X,
  y           = y,
  family      = "binomial",
  alpha       = 1,
  lambda      = lambda_min,
  standardize = TRUE
)

# 5. Extract coefficients into a data frame
coef_df <- as.matrix(coef(lasso_mod)) %>% 
  as.data.frame() %>% 
  rownames_to_column("term")

# Rename the second column to "estimate"
names(coef_df)[2] <- "estimate"

# 6. Filter on absolute value > 0.01 and sort by magnitude
coef_df <- coef_df %>% 
  filter(term != "(Intercept)", abs(estimate) > 0.05) %>% 
  arrange(desc(abs(estimate)))

treatment_predictors <- coef_df$term

# 7. Print nicely
kable(coef_df, digits = 3, caption = "LASSO Coefficients (|estimate| > 0.05) for Treatment Model")


```

Fitting a logistic regression model to identify covariates that predict outcome using interactions in order to find potential effect modifiers.

```{r}
# Load required libraries
if (!require(glmnet)) install.packages("glmnet")
library(glmnet)
library(dplyr)
library(tibble)
library(knitr)

# 1. Prepare data: convert character columns to factors, drop missing
df_mod <- df %>%
  mutate(across(where(is.character), as.factor)) %>%
  drop_na()

# 2. Build formula including main effects and treatment interactions
#    Exclude post-treatment/time variables
excluded <- c(
  "hosp_exp_flg", "day_icu_intime", "day_icu_intime_num",
  "icu_exp_flg", "mort_day_censored", "censor_flg",
  "hour_icu_intime"
)
# All covariates except outcome and excluded
covs <- setdiff(names(df_mod), c("day_28_flg", excluded))
# Remove treatment from covariates list to add it separately
other_covs <- setdiff(covs, "aline_flg")

# Construct formula: main effects + interactions with treatment
form_str <- paste0(
  "day_28_flg ~ aline_flg + ",
  paste(other_covs, collapse = " + "), " + ",
  paste0("aline_flg:", other_covs, collapse = " + ")
)
formula_inter <- as.formula(form_str)

# 3. Define response vector y and design matrix X
y <- df_mod$day_28_flg
X <- model.matrix(formula_inter, data = df_mod)[, -1]

# 4. Cross-validated LASSO logistic regression
set.seed(123)
cvfit_outcome <- cv.glmnet(
  x           = X,
  y           = y,
  family      = "binomial",
  alpha       = 1,
  standardize = TRUE
)

# 5. Fit final model at the optimal λ
lambda_min_outcome <- cvfit_outcome$lambda.min
lasso_outcome <- glmnet(
  x           = X,
  y           = y,
  family      = "binomial",
  alpha       = 1,
  lambda      = lambda_min_outcome,
  standardize = TRUE
)

# 6. Extract coefficients into a data frame
coef_df_outcome <- as.matrix(coef(lasso_outcome)) %>%
  as.data.frame() %>%
  rownames_to_column("term")
names(coef_df_outcome)[2] <- "estimate"

# 7. Filter on |estimate| > 0.05 and sort by magnitude
coef_df_outcome <- coef_df_outcome %>%
  filter(term != "(Intercept)", abs(estimate) > 0.05) %>%
  arrange(desc(abs(estimate)))

# 8. Save selected terms as potential effect modifiers
outcome_predictors <- coef_df_outcome$term

potential_effect_modifiers <- coef_df_outcome %>%
  filter(grepl(":", term)) %>%
  pull(term)

# 9. Print nicely
kable(
  potential_effect_modifiers,
  digits  = 3,
  caption = "LASSO Coefficients (|estimate| > 0.05) for 28-Day Mortality Model with Treatment Interactions"
)

```

```{r}
potential_effect_modifiers <- sub("^.*:", "", potential_effect_modifiers)
potential_effect_modifiers
```

Finding potential con-founders based on the intersection between the variables that "survived" the lasso fit of the treatment prediction and predicting the outcomes.

```{r}
# Assuming potential_confounders and potential_effect_modifiers are already in your environment

library(tibble)
library(knitr)

# 1. Compute intersection
outcome_predictors <- union(outcome_predictors,potential_effect_modifiers)
potential_confounders <- intersect(treatment_predictors, outcome_predictors)

# 2. Create a tidy data frame
shared_df <- tibble(
  term = potential_confounders
)

# 3. Print nicely with a caption
kable(
  shared_df,
)


```

```{r}
potential_confounders <- potential_confounders[!potential_confounders %in% c("service_unitMICU", "service_unitSICU")]
potential_confounders <- c(potential_confounders, "service_unit")

potential_effect_modifiers <- potential_effect_modifiers[!potential_effect_modifiers %in% c("service_unitMICU", "service_unitSICU")]
potential_effect_modifiers <- c(potential_effect_modifiers, "service_unit")

treatment_predictors <- treatment_predictors[!treatment_predictors %in% c("service_unitMICU", "service_unitSICU")]
treatment_predictors <- c(treatment_predictors, "service_unit")
```

## Continuous Covariates Distributions

```{r}
# Split a vector of variable names into continuous vs. categorical/binary
split_covs <- function(var_list, df) {
  continuous <- var_list[sapply(var_list, function(v) {
    col <- df[[v]]
    is.numeric(col) && length(unique(na.omit(col))) > 2
  })]
  categorical <- var_list[sapply(var_list, function(v) {
    col <- df[[v]]
    is.factor(col) ||
    is.character(col) ||
    (is.numeric(col) && length(unique(na.omit(col))) <= 2)
  })]
  list(
    continuous = continuous,
    categorical = categorical
  )
}

# Apply to treatment predictors
tp_split <- split_covs(treatment_predictors, df)
treatment_predictors_continuous  <- tp_split$continuous
treatment_predictors_categorical <- tp_split$categorical

# Apply to potential effect modifiers
em_split <- split_covs(potential_effect_modifiers, df)
potential_effect_modifiers_continuous  <- em_split$continuous
potential_effect_modifiers_categorical <- em_split$categorical

# Apply split_covs to potential_confounders
pc_split <- split_covs(potential_confounders, df)

# Extract continuous vs. categorical lists
potential_confounders_continuous  <- pc_split$continuous
potential_confounders_categorical <- pc_split$categorical

```

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggridges)

# Helper function to plot density ridges if there are continuous vars
plot_density_ridges <- function(data, group_var, cont_vars, title, y_label) {
  if (length(cont_vars) == 0) {
    message("No continuous variables to plot for: ", title)
    return(invisible(NULL))
  }
  # Select the grouping column and continuous vars
  df_sub <- data %>% select(all_of(c(group_var, cont_vars)))
  # Only proceed if there is at least one continuous column
  if (ncol(df_sub) < 2) {
    message("Not enough columns to pivot for: ", title)
    return(invisible(NULL))
  }
  df_sub %>%
    pivot_longer(
      cols      = -all_of(group_var),
      names_to  = "Variable",
      values_to = "Value"
    ) %>%
    ggplot(aes(x = Value, y = factor(.data[[group_var]]), fill = factor(.data[[group_var]]))) +
      geom_density_ridges(alpha = 0.7, scale = 1.1) +
      facet_wrap(~ Variable, scales = "free_x", ncol = 3) +
      labs(
        title = title,
        y     = y_label,
        fill  = group_var
      ) +
      theme_minimal()
}

# 1) Treatment predictors by catheter use
plot_density_ridges(
  data       = df,
  group_var  = "aline_flg",
  cont_vars  = treatment_predictors_continuous,
  title      = "Density Ridges: Treatment Predictors by Catheter Use",
  y_label    = "Catheter (0=no, 1=yes)"
)

# 2) Potential confounders by catheter use
plot_density_ridges(
  data       = df,
  group_var  = "aline_flg",
  cont_vars  = potential_confounders_continuous,
  title      = "Density Ridges: Potential Confounders by Catheter Use",
  y_label    = "Catheter (0=no, 1=yes)"
)

# 3) Potential effect modifiers by 28-day mortality
plot_density_ridges(
  data       = df,
  group_var  = "day_28_flg",
  cont_vars  = potential_effect_modifiers_continuous,
  title      = "Density Ridges: Effect Modifiers by 28-Day Mortality",
  y_label    = "Mortality (0=survived, 1=died)"
)


```

## Categorical Covariates Histograms

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# Helper to plot bar charts for categorical/binary vars,
# coercing all selected vars to character so pivot_longer works
plot_cat_histograms <- function(data, group_var, cat_vars, title, legend_title) {
  if (length(cat_vars) == 0) {
    message("No categorical variables to plot for: ", title)
    return(invisible(NULL))
  }
  df_sub <- data %>%
    # coerce all categorical vars to character to avoid type conflicts
    mutate(across(all_of(cat_vars), as.character)) %>%
    select(all_of(c(group_var, cat_vars)))
    
  df_sub %>%
    pivot_longer(
      cols      = -all_of(group_var),
      names_to  = "Variable",
      values_to = "Value"
    ) %>%
    mutate(
      Group = factor(.data[[group_var]]),
      Value = factor(Value)
    ) %>%
    ggplot(aes(x = Value, fill = Group)) +
      geom_bar(position = "dodge") +
      facet_wrap(~ Variable, scales = "free_x", ncol = 4) +
      labs(
        title = title,
        x     = NULL,
        fill  = legend_title
      ) +
      theme_minimal()
}

# 1) Categorical Treatment Predictors by Catheter Use
plot_cat_histograms(
  data        = df,
  group_var   = "aline_flg",
  cat_vars    = treatment_predictors_categorical,
  title       = "Categorical Treatment Predictors by Catheter Use",
  legend_title= "Catheter"
)

# 2) Categorical Potential Confounders by Catheter Use
plot_cat_histograms(
  data        = df,
  group_var   = "aline_flg",
  cat_vars    = potential_confounders_categorical,
  title       = "Categorical Potential Confounders by Catheter Use",
  legend_title= "Catheter"
)

# 3) Categorical Potential Effect Modifiers by 28-Day Mortality
plot_cat_histograms(
  data        = df,
  group_var   = "day_28_flg",
  cat_vars    = potential_effect_modifiers_categorical,
  title       = "Categorical Effect Modifiers by 28-Day Mortality",
  legend_title= "Mortality"
)


```
